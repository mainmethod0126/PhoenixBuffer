import groovy.json.JsonSlurper
import java.nio.file.Paths


/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/7.3/userguide/building_java_projects.html
 */



plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}



void writeVersion(String major, String minor, String patch, String prereleaseVersion, String buildMetadata) {

	String tempPrereleaseVersion = "\"\"";
	if (prereleaseVersion != "" && prereleaseVersion != null) {
		tempPrereleaseVersion = "\"" + prereleaseVersion + "\"";
	}

	String tempBuildMetadata = "\"\"";
	if (buildMetadata != "" && buildMetadata != null) {
		tempBuildMetadata = "\"" + buildMetadata + "\"";
	}

	File versionJosnFile = new File("version.json");
	if (!versionJosnFile.exists()) {
		throw new GradleException("version.json file does not exist");
	}

	String json = """ {
		"major": """ + major + """,
		"minor": """ + minor + """,
		"patch": """ + patch + """,
		"prereleaseVersion": """ + tempPrereleaseVersion + """,
		"buildMetadata": """ + tempBuildMetadata + """
	} """

	versionJosnFile.write(json);
}


String versionIncreaser(String prevVersion) {
	Integer versionNumber = prevVersion as Integer;
	versionNumber++;
	return intToString(versionNumber); 
}

String intToString(Integer number) {
	return number + "";
}


String inputVersionIncrement(String versionName, String oldVersion) {
	println("Enter 'Y' if you want to increment the "+ versionName +" version, otherwise press any key");
	String inputFlag = System.in.newReader().readLine();
	String nextVersion;
    if (inputFlag == "Y" || inputFlag == "y") {
		nextVersion = String.valueOf(Integer.valueOf(oldVersion) + 1);
		println("version changed");
		println(versionName + " version : " + oldVersion + " ---> " + nextVersion);
	} else {
		nextVersion = oldVersion;
		println("version not change");
		println(versionName + " version : " + oldVersion);
	}
	return nextVersion;
}


build {
	sourceCompatibility = project.findProperty("javav") ?: sourceCompatibility

	String major = project.findProperty("major") ?: ""
	String minor = project.findProperty("minor") ?: ""
	String patch = project.findProperty("patch") ?: ""
    String prereleaseVersion = project.findProperty("pr") ?: ""
	String buildMetadata = project.findProperty("bm") ?: ""

	// 기존 버전 정보를 가져옵니다.
	File versionJosnFile = new File("version.json");
	if (!versionJosnFile.exists()) {
		if (versionJosnFile.createNewFile()) {
            versionJosnFile.write(
				 """ {
					"major": 1,
					"minor": 0,
					"patch": 0,
					"prereleaseVersion": "",
					"buildMetadata": "",
				} """
			);
        } else {
            throw new GradleException("create failed version.json");
        }
    }
	
	def json = new JsonSlurper().parseText(versionJosnFile.text);

	if (major == "") {
		major = json.major;
	}  else if (major == "++") {
		major = versionIncreaser(json.major + "");
	} 

	if (minor == "") {
		minor = json.minor;
	} else if (minor == "++") {
		minor = versionIncreaser(json.minor + "");
	}


	if (patch == "") {
		patch = json.patch;
	} else if (patch == "++") {
		patch = versionIncreaser(json.patch + "");
	}

	String delimiterIncludedprereleaseVersion = prereleaseVersion;
	if (prereleaseVersion != "") {
		delimiterIncludedprereleaseVersion = "-" + prereleaseVersion; 
	}

	String delimiterIncludedBuildMetadata = buildMetadata;
	if (buildMetadata != "") {
		delimiterIncludedBuildMetadata = "+" + buildMetadata; 
	}


    String applicationVersion = major + "." + minor + "." + patch + delimiterIncludedprereleaseVersion + delimiterIncludedBuildMetadata;
	println(applicationVersion);

    String buildDirPath = "./dist/${(new Date()).format('yyyy-MM-dd')}" + "/" + sourceCompatibility + "/" + applicationVersion + "/";

	version = applicationVersion;

    project.file(buildDirPath).mkdir()


	copy {
		// application-prod.yml
		from Paths.get("src", "main", "resources", "application-prod.yml");
		into buildDirPath + "/config/"

		// supported-features.yml
		from Paths.get("supported-features.yml");
		into buildDirPath + "/config/"

		// index_update_curl.sh
		from Paths.get("src", "main", "resources", "elastic_design", "script", "update", "linux", "index_update_curl.sh");
		into buildDirPath + "/config/"

		// releaseNote.txt
		from Paths.get("releaseNote.txt");
		into buildDirPath + "/config/"

		// logback-spring.xml
		from Paths.get("logback-spring.xml");
		into buildDirPath + "/config/"
	}

    jar {
        destinationDir = new File(buildDirPath)
        archiveBaseName = "phoenix-buffer"
        manifest {
            attributes(
                    "Application-Version": applicationVersion,
                    "Build-Date": "${(new Date()).format('yyyy-MM-dd HH:mm:ss')}",
            )
        }
    }

	println("patch version : ");
	println(patch);

    writeVersion(major, minor, patch, prereleaseVersion, buildMetadata);

    File artifactsPath = new File('artifacts_path');
    if (!artifactsPath.exists()) {
        if (artifactsPath.createNewFile()) {
            artifactsPath.write("");
        } else {
            throw new GradleException("create failed artifacts_path");
        }
    }

    artifactsPath.write(buildDirPath); 

    println("----------------------------------------------------------------------------------------------------")
    println("--------------------------------|                                 |---------------------------------")
    println("--------------------------------|           Build Result          |---------------------------------")
    println("--------------------------------|                                 |---------------------------------")
    println("----------------------------------------------------------------------------------------------------")
    println("Build version : " + applicationVersion);
    println("Build result path : " + buildDirPath);
    println("----------------------------------------------------------------------------------------------------")
    println("----------------------------------------------------------------------------------------------------")
    println("----------------------------------------------------------------------------------------------------")
}


compileJava.options.encoding = 'UTF-8'


dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation 'org.junit.jupiter:junit-jupiter:5.7.2'

    // This dependency is used by the application.
    implementation 'com.google.guava:guava:30.1.1-jre'
}

application {
    // Define the main class for the application.
    mainClass = 'phoenixbuffer.App'
}

tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}
